<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Piano</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom CSS for piano keys and layout */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrolling on mobile */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            background-color: #1a202c; /* Dark background */
        }

        .piano-container {
            position: relative;
            display: flex;
            width: 100vw; /* Full viewport width */
            height: 80vh; /* Take up most of the vertical space */
            max-width: 900px; /* Limit max width for larger screens */
            background-color: #333;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            padding: 1rem;
            box-sizing: border-box; /* Include padding in width/height */
        }

        .white-keys {
            display: flex;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }

        .black-keys {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* This container spans the full width of the piano */
            height: 60%; /* Black keys are shorter */
            display: flex;
            z-index: 2;
            pointer-events: none; /* Allow clicks to pass through to white keys where there's no black key */
        }

        .key {
            flex-grow: 1;
            border-radius: 0.5rem;
            margin: 0 2px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 10px;
            font-size: 0.8rem;
            user-select: none; /* Prevent text selection on tap */
            transition: background-color 0.1s ease-out, transform 0.05s ease-out;
            box-sizing: border-box;
        }

        .white-key {
            background-color: #f8f8f8;
            border: 1px solid #ccc;
            box-shadow: inset 0 -5px 10px rgba(0, 0, 0, 0.2);
            position: relative;
            height: 100%;
        }

        .white-key.active {
            background-color: #e0e0e0;
            transform: translateY(2px);
            box-shadow: inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        .black-key {
            background-color: #222;
            border: 1px solid #000;
            box-shadow: inset 0 -5px 10px rgba(0, 0, 0, 0.5);
            position: absolute; /* Positioned relative to .black-keys container */
            /*
             * Calculate black key width as a percentage of a single white key's width.
             * There are 8 white keys, so each white key is 100% / 8.
             * We want the black key to be approximately 60% of a white key's width.
             */
            width: calc(100% / 8 * 0.6);
            height: 100%;
            margin: 0; /* Override white key margin */
            z-index: 3; /* Ensure black keys are on top */
            pointer-events: auto; /* Make black keys clickable */
            color: white; /* Black key note color */
        }

        .black-key.active {
            background-color: #000;
            transform: translateY(2px);
            box-shadow: inset 0 -2px 5px rgba(0, 0, 0, 0.5);
        }

        /*
         * Adjust black key positions relative to white keys.
         * The 'left' value is calculated to center the black key over the gap between two white keys.
         * The formula is: (white_key_index_after_gap * (100% / total_white_keys)) - (black_key_width / 2)
         * Where black_key_width is calc(100% / 8 * 0.6)
         * This simplifies to: (white_key_index_after_gap - 0.3) * (100% / 8)
         */
        /* C#4 (between C4 and D4, so after 1st white key slot) */
        .black-key[data-note="C#4"] { left: calc((100% / 8) * 0.7); }
        /* D#4 (between D4 and E4, so after 2nd white key slot) */
        .black-key[data-note="D#4"] { left: calc((100% / 8) * 1.7); }
        /* F#4 (between F4 and G4, so after 4th white key slot) */
        .black-key[data-note="F#4"] { left: calc((100% / 8) * 3.7); }
        /* G#4 (between G4 and A4, so after 5th white key slot) */
        .black-key[data-note="G#4"] { left: calc((100% / 8) * 4.7); }
        /* A#4 (between A4 and B4, so after 6th white key slot) */
        .black-key[data-note="A#4"] { left: calc((100% / 8) * 5.7); }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .piano-container {
                height: 90vh; /* More height on smaller screens */
                padding: 0.5rem;
            }
            .key {
                font-size: 0.7rem;
                padding-bottom: 5px;
            }
            .black-keys {
                height: 55%; /* Slightly shorter black keys on mobile */
            }
        }

        @media (max-width: 480px) {
            .piano-container {
                height: 95vh; /* Even more height on very small screens */
                padding: 0.2rem;
            }
            .key {
                font-size: 0.6rem;
                padding-bottom: 3px;
                margin: 0 1px;
            }
        }
    </style>
</head>
<body>
    <div class="piano-container">
        <div class="white-keys">
            <!-- White Keys -->
            <div class="key white-key" data-note="C4">C</div>
            <div class="key white-key" data-note="D4">D</div>
            <div class="key white-key" data-note="E4">E</div>
            <div class="key white-key" data-note="F4">F</div>
            <div class="key white-key" data-note="G4">G</div>
            <div class="key white-key" data-note="A4">A</div>
            <div class="key white-key" data-note="B4">B</div>
            <div class="key white-key" data-note="C5">C</div>
        </div>
        <div class="black-keys">
            <!-- Black Keys (positioned absolutely) -->
            <div class="key black-key" data-note="C#4">C#</div>
            <div class="key black-key" data-note="D#4">D#</div>
            <div class="key black-key" data-note="F#4">F#</div>
            <div class="key black-key" data-note="G#4">G#</div>
            <div class="key black-key" data-note="A#4">A#</div>
        </div>
    </div>

    <script>
        // Ensure Tone.js is loaded and ready
        window.onload = function() {
            // Create a reverb effect
            const reverb = new Tone.Reverb({
                decay: 2,    // How long the reverb tail lasts (seconds)
                preDelay: 0.01, // Time before reverb starts
                wet: 0.4     // Amount of wet signal (reverb) vs dry signal (original)
            }).toDestination(); // Connect reverb to the speakers

            // Create a synth with a triangle oscillator and adjusted envelope for a more piano-like sound
            const synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: {
                    type: "triangle" // Changed to triangle for a richer sound
                },
                envelope: {
                    attack: 0.005, // Very fast attack
                    decay: 0.4,   // Moderate decay
                    sustain: 0.1, // Short sustain
                    release: 1.2  // Longer release for piano resonance
                }
            }).connect(reverb); // Connect the synth to the reverb

            // Function to activate audio context on first user interaction
            function activateAudioContext() {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                    console.log('AudioContext resumed!');
                }
                // Remove the event listener after activation
                document.removeEventListener('touchstart', activateAudioContext);
                document.removeEventListener('mousedown', activateAudioContext);
            }

            // Add event listeners for touchstart and mousedown to activate audio context
            document.addEventListener('touchstart', activateAudioContext, { once: true });
            document.addEventListener('mousedown', activateAudioContext, { once: true });

            const pianoKeys = document.querySelectorAll('.key');
            let activeTouches = {}; // To track multiple touches for polyphony

            // Function to play a note
            function playNote(note, keyElement) {
                synth.triggerAttack(note);
                keyElement.classList.add('active');
            }

            // Function to release a note
            function releaseNote(note, keyElement) {
                synth.triggerRelease(note);
                keyElement.classList.remove('active');
            }

            // Event listeners for mouse interaction
            pianoKeys.forEach(key => {
                const note = key.dataset.note;

                key.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Prevent text selection on long press
                    playNote(note, key);
                });

                key.addEventListener('mouseup', () => {
                    releaseNote(note, key);
                });

                // Handle mouse leaving the key while pressed
                key.addEventListener('mouseleave', () => {
                    if (key.classList.contains('active')) {
                        releaseNote(note, key);
                    }
                });
            });

            // Event listeners for touch interaction (mobile)
            pianoKeys.forEach(key => {
                const note = key.dataset.note;

                key.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent default browser touch behavior (e.g., scrolling)
                    // Iterate through all touches to handle multi-touch
                    Array.from(e.changedTouches).forEach(touch => {
                        const targetKey = e.target.closest('.key');
                        if (targetKey && targetKey === key) { // Ensure the touch started on this key
                            playNote(note, key);
                            activeTouches[touch.identifier] = { keyElement: key, note: note };
                        }
                    });
                }, { passive: false }); // Use passive: false to allow preventDefault

                key.addEventListener('touchend', (e) => {
                    e.preventDefault(); // Prevent default browser touch behavior
                    Array.from(e.changedTouches).forEach(touch => {
                        if (activeTouches[touch.identifier]) {
                            releaseNote(activeTouches[touch.identifier].note, activeTouches[touch.identifier].keyElement);
                            delete activeTouches[touch.identifier];
                        }
                    });
                });

                key.addEventListener('touchcancel', (e) => {
                    e.preventDefault(); // Prevent default browser touch behavior
                    Array.from(e.changedTouches).forEach(touch => {
                        if (activeTouches[touch.identifier]) {
                            releaseNote(activeTouches[touch.identifier].note, activeTouches[touch.identifier].keyElement);
                            delete activeTouches[touch.identifier];
                        }
                    });
                });

                // Prevent accidental note release if finger slides off slightly
                key.addEventListener('touchmove', (e) => {
                    // This is important to ensure the note continues to play if the finger
                    // moves slightly within the key's bounds, but doesn't release it.
                    // We don't want to release the note unless the touch ends or moves significantly off.
                    // For a simple piano, we primarily care about touchstart/touchend.
                    // More complex logic might involve checking if the touch moves to another key.
                });
            });

            // Handle global touch/mouse release to ensure notes are turned off
            document.addEventListener('mouseup', () => {
                pianoKeys.forEach(key => {
                    if (key.classList.contains('active')) {
                        releaseNote(key.dataset.note, key);
                    }
                });
            });

            document.addEventListener('touchend', (e) => {
                // This global touchend is a fallback. The per-key touchend should handle most cases.
                // This ensures any lingering active keys are reset if a touch ends outside a key.
                if (Object.keys(activeTouches).length === 0) {
                     pianoKeys.forEach(key => {
                        if (key.classList.contains('active')) {
                            releaseNote(key.dataset.note, key);
                        }
                    });
                }
            });
        };
    </script>
</body>
</html>
